// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.24.4
// source: takler_protocol/takler.proto

package takler_protocol

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TaklerServerClient is the client API for TaklerServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TaklerServerClient interface {
	// child command
	RunCommandInit(ctx context.Context, in *InitCommand, opts ...grpc.CallOption) (*ServiceResponse, error)
	RunCommandComplete(ctx context.Context, in *CompleteCommand, opts ...grpc.CallOption) (*ServiceResponse, error)
	RunCommandAbort(ctx context.Context, in *AbortCommand, opts ...grpc.CallOption) (*ServiceResponse, error)
	RunCommandEvent(ctx context.Context, in *EventCommand, opts ...grpc.CallOption) (*ServiceResponse, error)
	RunCommandMeter(ctx context.Context, in *MeterCommand, opts ...grpc.CallOption) (*ServiceResponse, error)
	RunCommandRequeue(ctx context.Context, in *RequeueCommand, opts ...grpc.CallOption) (*ServiceResponse, error)
	RunCommandSuspend(ctx context.Context, in *SuspendCommand, opts ...grpc.CallOption) (*ServiceResponse, error)
	RunCommandResume(ctx context.Context, in *SuspendCommand, opts ...grpc.CallOption) (*ServiceResponse, error)
	RunCommandRun(ctx context.Context, in *RunCommand, opts ...grpc.CallOption) (*ServiceResponse, error)
	RunCommandForce(ctx context.Context, in *ForceCommand, opts ...grpc.CallOption) (*ServiceResponse, error)
	RunCommandFreeDep(ctx context.Context, in *FreeDepCommand, opts ...grpc.CallOption) (*ServiceResponse, error)
	RunCommandLoad(ctx context.Context, in *LoadCommand, opts ...grpc.CallOption) (*ServiceResponse, error)
	RunRequestShow(ctx context.Context, in *ShowRequest, opts ...grpc.CallOption) (*ShowResponse, error)
	RunRequestPing(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	QueryCoroutine(ctx context.Context, in *CoroutineRequest, opts ...grpc.CallOption) (*CoroutineResponse, error)
}

type taklerServerClient struct {
	cc grpc.ClientConnInterface
}

func NewTaklerServerClient(cc grpc.ClientConnInterface) TaklerServerClient {
	return &taklerServerClient{cc}
}

func (c *taklerServerClient) RunCommandInit(ctx context.Context, in *InitCommand, opts ...grpc.CallOption) (*ServiceResponse, error) {
	out := new(ServiceResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunCommandInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) RunCommandComplete(ctx context.Context, in *CompleteCommand, opts ...grpc.CallOption) (*ServiceResponse, error) {
	out := new(ServiceResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunCommandComplete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) RunCommandAbort(ctx context.Context, in *AbortCommand, opts ...grpc.CallOption) (*ServiceResponse, error) {
	out := new(ServiceResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunCommandAbort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) RunCommandEvent(ctx context.Context, in *EventCommand, opts ...grpc.CallOption) (*ServiceResponse, error) {
	out := new(ServiceResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunCommandEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) RunCommandMeter(ctx context.Context, in *MeterCommand, opts ...grpc.CallOption) (*ServiceResponse, error) {
	out := new(ServiceResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunCommandMeter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) RunCommandRequeue(ctx context.Context, in *RequeueCommand, opts ...grpc.CallOption) (*ServiceResponse, error) {
	out := new(ServiceResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunCommandRequeue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) RunCommandSuspend(ctx context.Context, in *SuspendCommand, opts ...grpc.CallOption) (*ServiceResponse, error) {
	out := new(ServiceResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunCommandSuspend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) RunCommandResume(ctx context.Context, in *SuspendCommand, opts ...grpc.CallOption) (*ServiceResponse, error) {
	out := new(ServiceResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunCommandResume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) RunCommandRun(ctx context.Context, in *RunCommand, opts ...grpc.CallOption) (*ServiceResponse, error) {
	out := new(ServiceResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunCommandRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) RunCommandForce(ctx context.Context, in *ForceCommand, opts ...grpc.CallOption) (*ServiceResponse, error) {
	out := new(ServiceResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunCommandForce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) RunCommandFreeDep(ctx context.Context, in *FreeDepCommand, opts ...grpc.CallOption) (*ServiceResponse, error) {
	out := new(ServiceResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunCommandFreeDep", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) RunCommandLoad(ctx context.Context, in *LoadCommand, opts ...grpc.CallOption) (*ServiceResponse, error) {
	out := new(ServiceResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunCommandLoad", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) RunRequestShow(ctx context.Context, in *ShowRequest, opts ...grpc.CallOption) (*ShowResponse, error) {
	out := new(ShowResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunRequestShow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) RunRequestPing(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/RunRequestPing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taklerServerClient) QueryCoroutine(ctx context.Context, in *CoroutineRequest, opts ...grpc.CallOption) (*CoroutineResponse, error) {
	out := new(CoroutineResponse)
	err := c.cc.Invoke(ctx, "/takler_protocol.TaklerServer/QueryCoroutine", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaklerServerServer is the server API for TaklerServer service.
// All implementations must embed UnimplementedTaklerServerServer
// for forward compatibility
type TaklerServerServer interface {
	// child command
	RunCommandInit(context.Context, *InitCommand) (*ServiceResponse, error)
	RunCommandComplete(context.Context, *CompleteCommand) (*ServiceResponse, error)
	RunCommandAbort(context.Context, *AbortCommand) (*ServiceResponse, error)
	RunCommandEvent(context.Context, *EventCommand) (*ServiceResponse, error)
	RunCommandMeter(context.Context, *MeterCommand) (*ServiceResponse, error)
	RunCommandRequeue(context.Context, *RequeueCommand) (*ServiceResponse, error)
	RunCommandSuspend(context.Context, *SuspendCommand) (*ServiceResponse, error)
	RunCommandResume(context.Context, *SuspendCommand) (*ServiceResponse, error)
	RunCommandRun(context.Context, *RunCommand) (*ServiceResponse, error)
	RunCommandForce(context.Context, *ForceCommand) (*ServiceResponse, error)
	RunCommandFreeDep(context.Context, *FreeDepCommand) (*ServiceResponse, error)
	RunCommandLoad(context.Context, *LoadCommand) (*ServiceResponse, error)
	RunRequestShow(context.Context, *ShowRequest) (*ShowResponse, error)
	RunRequestPing(context.Context, *PingRequest) (*PingResponse, error)
	QueryCoroutine(context.Context, *CoroutineRequest) (*CoroutineResponse, error)
	mustEmbedUnimplementedTaklerServerServer()
}

// UnimplementedTaklerServerServer must be embedded to have forward compatible implementations.
type UnimplementedTaklerServerServer struct {
}

func (UnimplementedTaklerServerServer) RunCommandInit(context.Context, *InitCommand) (*ServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommandInit not implemented")
}
func (UnimplementedTaklerServerServer) RunCommandComplete(context.Context, *CompleteCommand) (*ServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommandComplete not implemented")
}
func (UnimplementedTaklerServerServer) RunCommandAbort(context.Context, *AbortCommand) (*ServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommandAbort not implemented")
}
func (UnimplementedTaklerServerServer) RunCommandEvent(context.Context, *EventCommand) (*ServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommandEvent not implemented")
}
func (UnimplementedTaklerServerServer) RunCommandMeter(context.Context, *MeterCommand) (*ServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommandMeter not implemented")
}
func (UnimplementedTaklerServerServer) RunCommandRequeue(context.Context, *RequeueCommand) (*ServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommandRequeue not implemented")
}
func (UnimplementedTaklerServerServer) RunCommandSuspend(context.Context, *SuspendCommand) (*ServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommandSuspend not implemented")
}
func (UnimplementedTaklerServerServer) RunCommandResume(context.Context, *SuspendCommand) (*ServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommandResume not implemented")
}
func (UnimplementedTaklerServerServer) RunCommandRun(context.Context, *RunCommand) (*ServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommandRun not implemented")
}
func (UnimplementedTaklerServerServer) RunCommandForce(context.Context, *ForceCommand) (*ServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommandForce not implemented")
}
func (UnimplementedTaklerServerServer) RunCommandFreeDep(context.Context, *FreeDepCommand) (*ServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommandFreeDep not implemented")
}
func (UnimplementedTaklerServerServer) RunCommandLoad(context.Context, *LoadCommand) (*ServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommandLoad not implemented")
}
func (UnimplementedTaklerServerServer) RunRequestShow(context.Context, *ShowRequest) (*ShowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunRequestShow not implemented")
}
func (UnimplementedTaklerServerServer) RunRequestPing(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunRequestPing not implemented")
}
func (UnimplementedTaklerServerServer) QueryCoroutine(context.Context, *CoroutineRequest) (*CoroutineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryCoroutine not implemented")
}
func (UnimplementedTaklerServerServer) mustEmbedUnimplementedTaklerServerServer() {}

// UnsafeTaklerServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaklerServerServer will
// result in compilation errors.
type UnsafeTaklerServerServer interface {
	mustEmbedUnimplementedTaklerServerServer()
}

func RegisterTaklerServerServer(s grpc.ServiceRegistrar, srv TaklerServerServer) {
	s.RegisterService(&TaklerServer_ServiceDesc, srv)
}

func _TaklerServer_RunCommandInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunCommandInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunCommandInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunCommandInit(ctx, req.(*InitCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_RunCommandComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunCommandComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunCommandComplete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunCommandComplete(ctx, req.(*CompleteCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_RunCommandAbort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbortCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunCommandAbort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunCommandAbort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunCommandAbort(ctx, req.(*AbortCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_RunCommandEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunCommandEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunCommandEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunCommandEvent(ctx, req.(*EventCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_RunCommandMeter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MeterCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunCommandMeter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunCommandMeter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunCommandMeter(ctx, req.(*MeterCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_RunCommandRequeue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequeueCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunCommandRequeue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunCommandRequeue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunCommandRequeue(ctx, req.(*RequeueCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_RunCommandSuspend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuspendCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunCommandSuspend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunCommandSuspend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunCommandSuspend(ctx, req.(*SuspendCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_RunCommandResume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuspendCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunCommandResume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunCommandResume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunCommandResume(ctx, req.(*SuspendCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_RunCommandRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunCommandRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunCommandRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunCommandRun(ctx, req.(*RunCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_RunCommandForce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForceCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunCommandForce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunCommandForce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunCommandForce(ctx, req.(*ForceCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_RunCommandFreeDep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FreeDepCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunCommandFreeDep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunCommandFreeDep",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunCommandFreeDep(ctx, req.(*FreeDepCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_RunCommandLoad_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunCommandLoad(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunCommandLoad",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunCommandLoad(ctx, req.(*LoadCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_RunRequestShow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunRequestShow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunRequestShow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunRequestShow(ctx, req.(*ShowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_RunRequestPing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).RunRequestPing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/RunRequestPing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).RunRequestPing(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaklerServer_QueryCoroutine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoroutineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaklerServerServer).QueryCoroutine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/takler_protocol.TaklerServer/QueryCoroutine",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaklerServerServer).QueryCoroutine(ctx, req.(*CoroutineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TaklerServer_ServiceDesc is the grpc.ServiceDesc for TaklerServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaklerServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "takler_protocol.TaklerServer",
	HandlerType: (*TaklerServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunCommandInit",
			Handler:    _TaklerServer_RunCommandInit_Handler,
		},
		{
			MethodName: "RunCommandComplete",
			Handler:    _TaklerServer_RunCommandComplete_Handler,
		},
		{
			MethodName: "RunCommandAbort",
			Handler:    _TaklerServer_RunCommandAbort_Handler,
		},
		{
			MethodName: "RunCommandEvent",
			Handler:    _TaklerServer_RunCommandEvent_Handler,
		},
		{
			MethodName: "RunCommandMeter",
			Handler:    _TaklerServer_RunCommandMeter_Handler,
		},
		{
			MethodName: "RunCommandRequeue",
			Handler:    _TaklerServer_RunCommandRequeue_Handler,
		},
		{
			MethodName: "RunCommandSuspend",
			Handler:    _TaklerServer_RunCommandSuspend_Handler,
		},
		{
			MethodName: "RunCommandResume",
			Handler:    _TaklerServer_RunCommandResume_Handler,
		},
		{
			MethodName: "RunCommandRun",
			Handler:    _TaklerServer_RunCommandRun_Handler,
		},
		{
			MethodName: "RunCommandForce",
			Handler:    _TaklerServer_RunCommandForce_Handler,
		},
		{
			MethodName: "RunCommandFreeDep",
			Handler:    _TaklerServer_RunCommandFreeDep_Handler,
		},
		{
			MethodName: "RunCommandLoad",
			Handler:    _TaklerServer_RunCommandLoad_Handler,
		},
		{
			MethodName: "RunRequestShow",
			Handler:    _TaklerServer_RunRequestShow_Handler,
		},
		{
			MethodName: "RunRequestPing",
			Handler:    _TaklerServer_RunRequestPing_Handler,
		},
		{
			MethodName: "QueryCoroutine",
			Handler:    _TaklerServer_QueryCoroutine_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "takler_protocol/takler.proto",
}
